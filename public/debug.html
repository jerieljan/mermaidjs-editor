<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monaco Editor Debug Page</title>
    <style>
        body {
            font-family: monospace;
            margin: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        .log {
            background: #2d2d30;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .error { color: #f48771; }
        .success { color: #4ec9b0; }
        .warning { color: #dcdcaa; }
        .info { color: #9cdcfe; }
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #1177bb;
        }
        #editor {
            width: 100%;
            height: 400px;
            border: 1px solid #3c3c3c;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>Monaco Editor Debug Page</h1>
    <p>This page helps diagnose Monaco Editor issues on Vercel deployment.</p>
    
    <div>
        <button onclick="runDiagnostics()">Run Diagnostics</button>
        <button onclick="testMonacoLoad()">Test Monaco Load</button>
        <button onclick="testWorkerCreation()">Test Worker Creation</button>
        <button onclick="clearLogs()">Clear Logs</button>
    </div>
    
    <div id="logs" class="log"></div>
    
    <div id="editor"></div>

    <script>
        let logContainer = document.getElementById('logs');
        
        function log(message, type = 'info') {
            const timestamp = new Date().toISOString();
            const logEntry = document.createElement('div');
            logEntry.className = type;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        function clearLogs() {
            logContainer.innerHTML = '';
        }
        
        async function runDiagnostics() {
            log('ðŸ” Starting Monaco Editor Diagnostics...', 'info');
            
            // Environment info
            log(`Environment: ${location.hostname}`, 'info');
            log(`Protocol: ${location.protocol}`, 'info');
            log(`User Agent: ${navigator.userAgent}`, 'info');
            
            // Service Worker check
            if ('serviceWorker' in navigator) {
                try {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    log(`Service Workers: ${registrations.length} registered`, 'info');
                    registrations.forEach((reg, i) => {
                        log(`SW ${i}: ${reg.scope} (${reg.active?.state})`, 'info');
                    });
                } catch (error) {
                    log(`Service Worker check failed: ${error.message}`, 'error');
                }
            } else {
                log('Service Worker not supported', 'warning');
            }
            
            // CSP check
            try {
                // Try to create a worker to test CSP
                const workerBlob = new Blob(['self.postMessage("test")'], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(workerBlob);
                const testWorker = new Worker(workerUrl);
                testWorker.onmessage = () => {
                    log('âœ… Worker creation allowed by CSP', 'success');
                    testWorker.terminate();
                    URL.revokeObjectURL(workerUrl);
                };
                testWorker.onerror = (error) => {
                    log(`âŒ Worker creation blocked: ${error.message}`, 'error');
                    URL.revokeObjectURL(workerUrl);
                };
            } catch (error) {
                log(`âŒ Worker creation failed: ${error.message}`, 'error');
            }
            
            // Check for Monaco resources
            try {
                const response = await fetch('/assets/');
                log(`Assets directory accessible: ${response.status}`, response.ok ? 'success' : 'error');
            } catch (error) {
                log(`Assets check failed: ${error.message}`, 'error');
            }
            
            log('ðŸ Diagnostics complete', 'info');
        }
        
        async function testMonacoLoad() {
            log('ðŸŽ¯ Testing Monaco Editor Load...', 'info');
            
            // First, let's test service worker behavior with Monaco requests
            if ('serviceWorker' in navigator) {
                try {
                    const registration = await navigator.serviceWorker.ready;
                    log('ðŸ“¡ Service Worker Ready for Monaco Test', 'info');
                    
                    // Send a message to get SW version
                    const messageChannel = new MessageChannel();
                    messageChannel.port1.onmessage = (event) => {
                        log(`ðŸ“¨ SW Version: ${event.data.version}`, 'info');
                    };
                    registration.active?.postMessage({ type: 'GET_VERSION' }, [messageChannel.port2]);
                } catch (error) {
                    log(`âš ï¸ SW Ready Check Failed: ${error.message}`, 'warning');
                }
            }
            
            try {
                // Use the same Monaco version as the main app (@monaco-editor/react v4.7.0 uses Monaco 0.52.2)
                const monacoVersion = '0.52.2';
                const script = document.createElement('script');
                script.src = `https://cdn.jsdelivr.net/npm/monaco-editor@${monacoVersion}/min/vs/loader.js`;
                
                // Add detailed logging for script loading
                log(`ðŸ“¥ Loading Monaco Loader: ${script.src}`, 'info');
                
                script.onload = () => {
                    log('âœ… Monaco loader script loaded successfully', 'success');
                    
                    if (window.require) {
                        const vsPath = `https://cdn.jsdelivr.net/npm/monaco-editor@${monacoVersion}/min/vs`;
                        log(`ðŸ”§ Configuring Monaco paths: ${vsPath}`, 'info');
                        
                        window.require.config({ 
                            paths: { 
                                'vs': vsPath
                            } 
                        });
                        
                        log('ðŸ“¦ Loading Monaco editor main module...', 'info');
                        window.require(['vs/editor/editor.main'], function() {
                            log('âœ… Monaco editor main module loaded', 'success');
                            
                            try {
                                log('ðŸŽ¨ Creating Monaco editor instance...', 'info');
                                const editor = monaco.editor.create(document.getElementById('editor'), {
                                    value: 'console.log("Hello Monaco!");',
                                    language: 'javascript',
                                    theme: 'vs-dark'
                                });
                                log('âœ… Monaco editor created successfully', 'success');
                                log(`ðŸ“Š Monaco version: ${monaco.version || 'unknown'}`, 'info');
                                
                                // Test worker functionality with more detailed logging
                                setTimeout(() => {
                                    log('ðŸ”§ Testing Monaco worker functionality...', 'info');
                                    editor.setValue('// Testing worker functionality\nconst x = 1;\nconst y = 2;\nconst z = x + y;\n\n// This should trigger language services');
                                    log('âœ… Monaco editor content updated', 'success');
                                    
                                    // Check for any markers (errors/warnings) that might indicate worker issues
                                    setTimeout(() => {
                                        const model = editor.getModel();
                                        if (model) {
                                            const markers = monaco.editor.getModelMarkers({ resource: model.uri });
                                            if (markers.length > 0) {
                                                log(`ðŸ“ Editor markers found: ${markers.length}`, 'info');
                                                markers.forEach(marker => {
                                                    log(`  - ${marker.severity}: ${marker.message}`, 'info');
                                                });
                                            } else {
                                                log('âœ… No editor markers - workers functioning correctly', 'success');
                                            }
                                        }
                                    }, 2000);
                                }, 1000);
                                
                            } catch (error) {
                                log(`âŒ Monaco editor creation failed: ${error.message}`, 'error');
                                log(`Stack trace: ${error.stack}`, 'error');
                            }
                        }, (error) => {
                            log(`âŒ Monaco editor main module load failed: ${error}`, 'error');
                        });
                    } else {
                        log('âŒ Monaco require not available after script load', 'error');
                    }
                };
                
                script.onerror = (error) => {
                    log(`âŒ Monaco loader script failed to load`, 'error');
                    log(`Error details: ${JSON.stringify({
                        type: error.type,
                        target: error.target?.src,
                        message: error.message
                    })}`, 'error');
                };
                
                // Monitor network requests for Monaco resources
                const originalFetch = window.fetch;
                window.fetch = function(...args) {
                    const url = args[0];
                    if (typeof url === 'string' && (url.includes('monaco') || url.includes('jsdelivr.net'))) {
                        log(`ðŸŒ Monaco Fetch Request: ${url}`, 'info');
                    }
                    return originalFetch.apply(this, args).then(response => {
                        if (typeof url === 'string' && (url.includes('monaco') || url.includes('jsdelivr.net'))) {
                            log(`ðŸ“¥ Monaco Fetch Response: ${url} - ${response.status} ${response.statusText}`, 
                                response.ok ? 'success' : 'error');
                        }
                        return response;
                    }).catch(error => {
                        if (typeof url === 'string' && (url.includes('monaco') || url.includes('jsdelivr.net'))) {
                            log(`âŒ Monaco Fetch Error: ${url} - ${error.message}`, 'error');
                        }
                        throw error;
                    });
                };
                
                document.head.appendChild(script);
                
            } catch (error) {
                log(`âŒ Monaco load test setup failed: ${error.message}`, 'error');
                log(`Stack trace: ${error.stack}`, 'error');
            }
        }
        
        function testWorkerCreation() {
            log('ðŸ”§ Testing Worker Creation...', 'info');
            
            const workerTests = [
                {
                    name: 'Blob Worker',
                    create: () => {
                        const blob = new Blob(['self.postMessage("blob worker test")'], { type: 'application/javascript' });
                        const url = URL.createObjectURL(blob);
                        return { worker: new Worker(url), cleanup: () => URL.revokeObjectURL(url) };
                    }
                },
                {
                    name: 'Data URL Worker',
                    create: () => {
                        const dataUrl = 'data:application/javascript,self.postMessage("data url worker test")';
                        return { worker: new Worker(dataUrl), cleanup: () => {} };
                    }
                }
            ];
            
            workerTests.forEach(test => {
                try {
                    const { worker, cleanup } = test.create();
                    worker.onmessage = (e) => {
                        log(`âœ… ${test.name} success: ${e.data}`, 'success');
                        worker.terminate();
                        cleanup();
                    };
                    worker.onerror = (error) => {
                        log(`âŒ ${test.name} error: ${error.message}`, 'error');
                        cleanup();
                    };
                    worker.postMessage('test');
                } catch (error) {
                    log(`âŒ ${test.name} creation failed: ${error.message}`, 'error');
                }
            });
        }
        
        // Monitor CSP violations
        document.addEventListener('securitypolicyviolation', (e) => {
            log(`ðŸš¨ CSP Violation: ${e.violatedDirective} - ${e.blockedURI}`, 'error');
        });
        
        // Auto-run diagnostics on load
        window.addEventListener('load', () => {
            setTimeout(runDiagnostics, 1000);
        });
    </script>
</body>
</html>
